/*
* Copyright 2023 nanato12
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/*
 * Channel Access Token API
 *
 * This document describes Channel Access Token API.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::channel_access_token::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`gets_all_valid_channel_access_token_key_ids`]
#[derive(Clone, Debug)]
pub struct GetsAllValidChannelAccessTokenKeyIdsParams {
    /// `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`
    pub client_assertion_type: String,
    /// A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.
    pub client_assertion: String
}

/// struct for passing parameters to the method [`issue_channel_token`]
#[derive(Clone, Debug)]
pub struct IssueChannelTokenParams {
    /// `client_credentials`
    pub grant_type: Option<String>,
    /// Channel ID.
    pub client_id: Option<String>,
    /// Channel secret.
    pub client_secret: Option<String>
}

/// struct for passing parameters to the method [`issue_channel_token_by_jwt`]
#[derive(Clone, Debug)]
pub struct IssueChannelTokenByJwtParams {
    /// client_credentials
    pub grant_type: Option<String>,
    /// urn:ietf:params:oauth:client-assertion-type:jwt-bearer
    pub client_assertion_type: Option<String>,
    /// A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.
    pub client_assertion: Option<String>
}

/// struct for passing parameters to the method [`issue_stateless_channel_token`]
#[derive(Clone, Debug)]
pub struct IssueStatelessChannelTokenParams {
    /// `client_credentials`
    pub grant_type: Option<String>,
    /// URL-encoded value of `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`
    pub client_assertion_type: Option<String>,
    /// A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.
    pub client_assertion: Option<String>,
    /// Channel ID.
    pub client_id: Option<String>,
    /// Channel secret.
    pub client_secret: Option<String>
}

/// struct for passing parameters to the method [`revoke_channel_token`]
#[derive(Clone, Debug)]
pub struct RevokeChannelTokenParams {
    /// Channel access token
    pub access_token: Option<String>
}

/// struct for passing parameters to the method [`revoke_channel_token_by_jwt`]
#[derive(Clone, Debug)]
pub struct RevokeChannelTokenByJwtParams {
    /// Channel ID
    pub client_id: Option<String>,
    /// Channel Secret
    pub client_secret: Option<String>,
    /// Channel access token
    pub access_token: Option<String>
}

/// struct for passing parameters to the method [`verify_channel_token`]
#[derive(Clone, Debug)]
pub struct VerifyChannelTokenParams {
    /// A short-lived or long-lived channel access token.
    pub access_token: Option<String>
}

/// struct for passing parameters to the method [`verify_channel_token_by_jwt`]
#[derive(Clone, Debug)]
pub struct VerifyChannelTokenByJwtParams {
    /// Channel access token with a user-specified expiration (Channel Access Token v2.1).
    pub access_token: String
}


/// struct for typed errors of method [`gets_all_valid_channel_access_token_key_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetsAllValidChannelAccessTokenKeyIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issue_channel_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueChannelTokenError {
    Status400(crate::channel_access_token::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issue_channel_token_by_jwt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueChannelTokenByJwtError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issue_stateless_channel_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueStatelessChannelTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_channel_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeChannelTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_channel_token_by_jwt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeChannelTokenByJwtError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_channel_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyChannelTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_channel_token_by_jwt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyChannelTokenByJwtError {
    UnknownValue(serde_json::Value),
}


/// Gets all valid channel access token key IDs.
pub async fn gets_all_valid_channel_access_token_key_ids(configuration: &configuration::Configuration, params: GetsAllValidChannelAccessTokenKeyIdsParams) -> Result<crate::channel_access_token::models::ChannelAccessTokenKeyIdsResponse, Error<GetsAllValidChannelAccessTokenKeyIdsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let client_assertion_type = params.client_assertion_type;
    let client_assertion = params.client_assertion;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth2/v2.1/tokens/kid", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("client_assertion_type", &client_assertion_type.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("client_assertion", &client_assertion.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetsAllValidChannelAccessTokenKeyIdsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Issue short-lived channel access token
pub async fn issue_channel_token(configuration: &configuration::Configuration, params: IssueChannelTokenParams) -> Result<crate::channel_access_token::models::IssueShortLivedChannelAccessTokenResponse, Error<IssueChannelTokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let grant_type = params.grant_type;
    let client_id = params.client_id;
    let client_secret = params.client_secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/oauth/accessToken", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = grant_type {
        local_var_form_params.insert("grant_type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_id {
        local_var_form_params.insert("client_id", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_secret {
        local_var_form_params.insert("client_secret", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IssueChannelTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
pub async fn issue_channel_token_by_jwt(configuration: &configuration::Configuration, params: IssueChannelTokenByJwtParams) -> Result<crate::channel_access_token::models::IssueChannelAccessTokenResponse, Error<IssueChannelTokenByJwtError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let grant_type = params.grant_type;
    let client_assertion_type = params.client_assertion_type;
    let client_assertion = params.client_assertion;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth2/v2.1/token", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = grant_type {
        local_var_form_params.insert("grant_type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_assertion_type {
        local_var_form_params.insert("client_assertion_type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_assertion {
        local_var_form_params.insert("client_assertion", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IssueChannelTokenByJwtError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Issues a new stateless channel access token, which doesn't have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires. 
pub async fn issue_stateless_channel_token(configuration: &configuration::Configuration, params: IssueStatelessChannelTokenParams) -> Result<crate::channel_access_token::models::IssueStatelessChannelAccessTokenResponse, Error<IssueStatelessChannelTokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let grant_type = params.grant_type;
    let client_assertion_type = params.client_assertion_type;
    let client_assertion = params.client_assertion;
    let client_id = params.client_id;
    let client_secret = params.client_secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth2/v3/token", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = grant_type {
        local_var_form_params.insert("grant_type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_assertion_type {
        local_var_form_params.insert("client_assertion_type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_assertion {
        local_var_form_params.insert("client_assertion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_id {
        local_var_form_params.insert("client_id", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_secret {
        local_var_form_params.insert("client_secret", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IssueStatelessChannelTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Revoke short-lived or long-lived channel access token
pub async fn revoke_channel_token(configuration: &configuration::Configuration, params: RevokeChannelTokenParams) -> Result<(), Error<RevokeChannelTokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let access_token = params.access_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/oauth/revoke", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = access_token {
        local_var_form_params.insert("access_token", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<RevokeChannelTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Revoke channel access token v2.1
pub async fn revoke_channel_token_by_jwt(configuration: &configuration::Configuration, params: RevokeChannelTokenByJwtParams) -> Result<(), Error<RevokeChannelTokenByJwtError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let client_id = params.client_id;
    let client_secret = params.client_secret;
    let access_token = params.access_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth2/v2.1/revoke", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = client_id {
        local_var_form_params.insert("client_id", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_secret {
        local_var_form_params.insert("client_secret", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = access_token {
        local_var_form_params.insert("access_token", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<RevokeChannelTokenByJwtError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Verify the validity of short-lived and long-lived channel access tokens
pub async fn verify_channel_token(configuration: &configuration::Configuration, params: VerifyChannelTokenParams) -> Result<crate::channel_access_token::models::VerifyChannelAccessTokenResponse, Error<VerifyChannelTokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let access_token = params.access_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/oauth/verify", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = access_token {
        local_var_form_params.insert("access_token", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VerifyChannelTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
pub async fn verify_channel_token_by_jwt(configuration: &configuration::Configuration, params: VerifyChannelTokenByJwtParams) -> Result<crate::channel_access_token::models::VerifyChannelAccessTokenResponse, Error<VerifyChannelTokenByJwtError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let access_token = params.access_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth2/v2.1/verify", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("access_token", &access_token.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VerifyChannelTokenByJwtError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

