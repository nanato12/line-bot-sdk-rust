/*
* Copyright 2023 nanato12
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/*
 * LINE Messaging API
 *
 * This document describes LINE Messaging API.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::messaging_api::apis::ResponseContent;

/// struct for passing parameters to the method [`audience_match`]
#[derive(Clone, Debug)]
pub struct AudienceMatchParams {
    pub audience_match_messages_request: crate::messaging_api::models::AudienceMatchMessagesRequest,
}

/// struct for passing parameters to the method [`broadcast`]
#[derive(Clone, Debug)]
pub struct BroadcastParams {
    pub broadcast_request: crate::messaging_api::models::BroadcastRequest,
    /// Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.
    pub x_line_retry_key: Option<String>,
}

/// struct for passing parameters to the method [`create_rich_menu`]
#[derive(Clone, Debug)]
pub struct CreateRichMenuParams {
    pub rich_menu_request: crate::messaging_api::models::RichMenuRequest,
}

/// struct for passing parameters to the method [`create_rich_menu_alias`]
#[derive(Clone, Debug)]
pub struct CreateRichMenuAliasParams {
    pub create_rich_menu_alias_request: crate::messaging_api::models::CreateRichMenuAliasRequest,
}

/// struct for passing parameters to the method [`delete_rich_menu`]
#[derive(Clone, Debug)]
pub struct DeleteRichMenuParams {
    /// ID of a rich menu
    pub rich_menu_id: String,
}

/// struct for passing parameters to the method [`delete_rich_menu_alias`]
#[derive(Clone, Debug)]
pub struct DeleteRichMenuAliasParams {
    /// Rich menu alias ID that you want to delete.
    pub rich_menu_alias_id: String,
}

/// struct for passing parameters to the method [`get_ad_phone_message_statistics`]
#[derive(Clone, Debug)]
pub struct GetAdPhoneMessageStatisticsParams {
    /// Date the message was sent  Format: `yyyyMMdd` (e.g. `20190831`) Time Zone: UTC+9
    pub date: String,
}

/// struct for passing parameters to the method [`get_aggregation_unit_name_list`]
#[derive(Clone, Debug)]
pub struct GetAggregationUnitNameListParams {
    /// The maximum number of aggregation units you can get per request.
    pub limit: Option<String>,
    /// Value of the continuation token found in the next property of the JSON object returned in the response. If you can't get all the aggregation units in one request, include this parameter to get the remaining array.
    pub start: Option<String>,
}

/// struct for passing parameters to the method [`get_followers`]
#[derive(Clone, Debug)]
pub struct GetFollowersParams {
    /// Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs.
    pub start: Option<String>,
    /// The maximum number of user IDs to retrieve in a single request.
    pub limit: Option<i32>,
}

/// struct for passing parameters to the method [`get_group_member_count`]
#[derive(Clone, Debug)]
pub struct GetGroupMemberCountParams {
    /// Group ID
    pub group_id: String,
}

/// struct for passing parameters to the method [`get_group_member_profile`]
#[derive(Clone, Debug)]
pub struct GetGroupMemberProfileParams {
    /// Group ID
    pub group_id: String,
    /// User ID
    pub user_id: String,
}

/// struct for passing parameters to the method [`get_group_members_ids`]
#[derive(Clone, Debug)]
pub struct GetGroupMembersIdsParams {
    /// Group ID
    pub group_id: String,
    /// Value of the continuation token found in the `next` property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group.
    pub start: Option<String>,
}

/// struct for passing parameters to the method [`get_group_summary`]
#[derive(Clone, Debug)]
pub struct GetGroupSummaryParams {
    /// Group ID
    pub group_id: String,
}

/// struct for passing parameters to the method [`get_narrowcast_progress`]
#[derive(Clone, Debug)]
pub struct GetNarrowcastProgressParams {
    /// The narrowcast message's request ID. Each Messaging API request has a request ID.
    pub request_id: String,
}

/// struct for passing parameters to the method [`get_number_of_sent_broadcast_messages`]
#[derive(Clone, Debug)]
pub struct GetNumberOfSentBroadcastMessagesParams {
    /// Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9
    pub date: String,
}

/// struct for passing parameters to the method [`get_number_of_sent_multicast_messages`]
#[derive(Clone, Debug)]
pub struct GetNumberOfSentMulticastMessagesParams {
    /// Date the messages were sent  Format: `yyyyMMdd` (e.g. `20191231`) Timezone: UTC+9
    pub date: String,
}

/// struct for passing parameters to the method [`get_number_of_sent_push_messages`]
#[derive(Clone, Debug)]
pub struct GetNumberOfSentPushMessagesParams {
    /// Date the messages were sent  Format: `yyyyMMdd` (e.g. `20191231`) Timezone: UTC+9
    pub date: String,
}

/// struct for passing parameters to the method [`get_number_of_sent_reply_messages`]
#[derive(Clone, Debug)]
pub struct GetNumberOfSentReplyMessagesParams {
    /// Date the messages were sent  Format: `yyyyMMdd` (e.g. `20191231`) Timezone: UTC+9
    pub date: String,
}

/// struct for passing parameters to the method [`get_pnp_message_statistics`]
#[derive(Clone, Debug)]
pub struct GetPnpMessageStatisticsParams {
    /// Date the message was sent  Format: `yyyyMMdd` (Example:`20211231`) Time zone: UTC+9
    pub date: String,
}

/// struct for passing parameters to the method [`get_profile`]
#[derive(Clone, Debug)]
pub struct GetProfileParams {
    /// User ID
    pub user_id: String,
}

/// struct for passing parameters to the method [`get_rich_menu`]
#[derive(Clone, Debug)]
pub struct GetRichMenuParams {
    /// ID of a rich menu
    pub rich_menu_id: String,
}

/// struct for passing parameters to the method [`get_rich_menu_alias`]
#[derive(Clone, Debug)]
pub struct GetRichMenuAliasParams {
    /// The rich menu alias ID whose information you want to obtain.
    pub rich_menu_alias_id: String,
}

/// struct for passing parameters to the method [`get_rich_menu_batch_progress`]
#[derive(Clone, Debug)]
pub struct GetRichMenuBatchProgressParams {
    /// A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID.
    pub request_id: String,
}

/// struct for passing parameters to the method [`get_rich_menu_id_of_user`]
#[derive(Clone, Debug)]
pub struct GetRichMenuIdOfUserParams {
    /// User ID. Found in the `source` object of webhook event objects. Do not use the LINE ID used in LINE.
    pub user_id: String,
}

/// struct for passing parameters to the method [`get_room_member_count`]
#[derive(Clone, Debug)]
pub struct GetRoomMemberCountParams {
    /// Room ID
    pub room_id: String,
}

/// struct for passing parameters to the method [`get_room_member_profile`]
#[derive(Clone, Debug)]
pub struct GetRoomMemberProfileParams {
    /// Room ID
    pub room_id: String,
    /// User ID
    pub user_id: String,
}

/// struct for passing parameters to the method [`get_room_members_ids`]
#[derive(Clone, Debug)]
pub struct GetRoomMembersIdsParams {
    /// Room ID
    pub room_id: String,
    /// Value of the continuation token found in the `next` property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group.
    pub start: Option<String>,
}

/// struct for passing parameters to the method [`issue_link_token`]
#[derive(Clone, Debug)]
pub struct IssueLinkTokenParams {
    /// User ID for the LINE account to be linked. Found in the `source` object of account link event objects. Do not use the LINE ID used in LINE.
    pub user_id: String,
}

/// struct for passing parameters to the method [`leave_group`]
#[derive(Clone, Debug)]
pub struct LeaveGroupParams {
    /// Group ID
    pub group_id: String,
}

/// struct for passing parameters to the method [`leave_room`]
#[derive(Clone, Debug)]
pub struct LeaveRoomParams {
    /// Room ID
    pub room_id: String,
}

/// struct for passing parameters to the method [`link_rich_menu_id_to_user`]
#[derive(Clone, Debug)]
pub struct LinkRichMenuIdToUserParams {
    /// User ID. Found in the `source` object of webhook event objects. Do not use the LINE ID used in LINE.
    pub user_id: String,
    /// ID of a rich menu
    pub rich_menu_id: String,
}

/// struct for passing parameters to the method [`link_rich_menu_id_to_users`]
#[derive(Clone, Debug)]
pub struct LinkRichMenuIdToUsersParams {
    pub rich_menu_bulk_link_request: crate::messaging_api::models::RichMenuBulkLinkRequest,
}

/// struct for passing parameters to the method [`mark_messages_as_read`]
#[derive(Clone, Debug)]
pub struct MarkMessagesAsReadParams {
    pub mark_messages_as_read_request: crate::messaging_api::models::MarkMessagesAsReadRequest,
}

/// struct for passing parameters to the method [`multicast`]
#[derive(Clone, Debug)]
pub struct MulticastParams {
    pub multicast_request: crate::messaging_api::models::MulticastRequest,
    /// Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.
    pub x_line_retry_key: Option<String>,
}

/// struct for passing parameters to the method [`narrowcast`]
#[derive(Clone, Debug)]
pub struct NarrowcastParams {
    pub narrowcast_request: crate::messaging_api::models::NarrowcastRequest,
    /// Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.
    pub x_line_retry_key: Option<String>,
}

/// struct for passing parameters to the method [`push_message`]
#[derive(Clone, Debug)]
pub struct PushMessageParams {
    pub push_message_request: crate::messaging_api::models::PushMessageRequest,
    /// Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.
    pub x_line_retry_key: Option<String>,
}

/// struct for passing parameters to the method [`push_messages_by_phone`]
#[derive(Clone, Debug)]
pub struct PushMessagesByPhoneParams {
    pub pnp_messages_request: crate::messaging_api::models::PnpMessagesRequest,
    /// String returned in the delivery.data property of the delivery completion event via Webhook.
    pub x_line_delivery_tag: Option<String>,
}

/// struct for passing parameters to the method [`reply_message`]
#[derive(Clone, Debug)]
pub struct ReplyMessageParams {
    pub reply_message_request: crate::messaging_api::models::ReplyMessageRequest,
}

/// struct for passing parameters to the method [`rich_menu_batch`]
#[derive(Clone, Debug)]
pub struct RichMenuBatchParams {
    pub rich_menu_batch_request: crate::messaging_api::models::RichMenuBatchRequest,
}

/// struct for passing parameters to the method [`set_default_rich_menu`]
#[derive(Clone, Debug)]
pub struct SetDefaultRichMenuParams {
    /// ID of a rich menu
    pub rich_menu_id: String,
}

/// struct for passing parameters to the method [`set_webhook_endpoint`]
#[derive(Clone, Debug)]
pub struct SetWebhookEndpointParams {
    pub set_webhook_endpoint_request: crate::messaging_api::models::SetWebhookEndpointRequest,
}

/// struct for passing parameters to the method [`test_webhook_endpoint`]
#[derive(Clone, Debug)]
pub struct TestWebhookEndpointParams {
    pub test_webhook_endpoint_request:
        Option<crate::messaging_api::models::TestWebhookEndpointRequest>,
}

/// struct for passing parameters to the method [`unlink_rich_menu_id_from_user`]
#[derive(Clone, Debug)]
pub struct UnlinkRichMenuIdFromUserParams {
    /// User ID. Found in the `source` object of webhook event objects. Do not use the LINE ID used in LINE.
    pub user_id: String,
}

/// struct for passing parameters to the method [`unlink_rich_menu_id_from_users`]
#[derive(Clone, Debug)]
pub struct UnlinkRichMenuIdFromUsersParams {
    pub rich_menu_bulk_unlink_request: crate::messaging_api::models::RichMenuBulkUnlinkRequest,
}

/// struct for passing parameters to the method [`update_rich_menu_alias`]
#[derive(Clone, Debug)]
pub struct UpdateRichMenuAliasParams {
    /// The rich menu alias ID you want to update.
    pub rich_menu_alias_id: String,
    pub update_rich_menu_alias_request: crate::messaging_api::models::UpdateRichMenuAliasRequest,
}

/// struct for passing parameters to the method [`validate_broadcast`]
#[derive(Clone, Debug)]
pub struct ValidateBroadcastParams {
    pub validate_message_request: crate::messaging_api::models::ValidateMessageRequest,
}

/// struct for passing parameters to the method [`validate_multicast`]
#[derive(Clone, Debug)]
pub struct ValidateMulticastParams {
    pub validate_message_request: crate::messaging_api::models::ValidateMessageRequest,
}

/// struct for passing parameters to the method [`validate_narrowcast`]
#[derive(Clone, Debug)]
pub struct ValidateNarrowcastParams {
    pub validate_message_request: crate::messaging_api::models::ValidateMessageRequest,
}

/// struct for passing parameters to the method [`validate_push`]
#[derive(Clone, Debug)]
pub struct ValidatePushParams {
    pub validate_message_request: crate::messaging_api::models::ValidateMessageRequest,
}

/// struct for passing parameters to the method [`validate_reply`]
#[derive(Clone, Debug)]
pub struct ValidateReplyParams {
    pub validate_message_request: crate::messaging_api::models::ValidateMessageRequest,
}

/// struct for passing parameters to the method [`validate_rich_menu_batch_request`]
#[derive(Clone, Debug)]
pub struct ValidateRichMenuBatchRequestParams {
    pub rich_menu_batch_request: crate::messaging_api::models::RichMenuBatchRequest,
}

/// struct for passing parameters to the method [`validate_rich_menu_object`]
#[derive(Clone, Debug)]
pub struct ValidateRichMenuObjectParams {
    pub rich_menu_request: crate::messaging_api::models::RichMenuRequest,
}

/// struct for typed successes of method [`audience_match`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AudienceMatchSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`broadcast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BroadcastSuccess {
    Status200(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`cancel_default_rich_menu`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelDefaultRichMenuSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_rich_menu`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRichMenuSuccess {
    Status200(crate::messaging_api::models::RichMenuIdResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_rich_menu_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRichMenuAliasSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_rich_menu`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRichMenuSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_rich_menu_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRichMenuAliasSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_ad_phone_message_statistics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAdPhoneMessageStatisticsSuccess {
    Status200(crate::messaging_api::models::NumberOfMessagesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_aggregation_unit_name_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAggregationUnitNameListSuccess {
    Status200(crate::messaging_api::models::GetAggregationUnitNameListResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_aggregation_unit_usage`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAggregationUnitUsageSuccess {
    Status200(crate::messaging_api::models::GetAggregationUnitUsageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_bot_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBotInfoSuccess {
    Status200(crate::messaging_api::models::BotInfoResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_default_rich_menu_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultRichMenuIdSuccess {
    Status200(crate::messaging_api::models::RichMenuIdResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_followers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFollowersSuccess {
    Status200(crate::messaging_api::models::GetFollowersResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_group_member_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupMemberCountSuccess {
    Status200(crate::messaging_api::models::GroupMemberCountResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_group_member_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupMemberProfileSuccess {
    Status200(crate::messaging_api::models::GroupUserProfileResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_group_members_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupMembersIdsSuccess {
    Status200(crate::messaging_api::models::MembersIdsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_group_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupSummarySuccess {
    Status200(crate::messaging_api::models::GroupSummaryResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_message_quota`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMessageQuotaSuccess {
    Status200(crate::messaging_api::models::MessageQuotaResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_message_quota_consumption`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMessageQuotaConsumptionSuccess {
    Status200(crate::messaging_api::models::QuotaConsumptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_narrowcast_progress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNarrowcastProgressSuccess {
    Status200(crate::messaging_api::models::NarrowcastProgressResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_number_of_sent_broadcast_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNumberOfSentBroadcastMessagesSuccess {
    Status200(crate::messaging_api::models::NumberOfMessagesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_number_of_sent_multicast_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNumberOfSentMulticastMessagesSuccess {
    Status200(crate::messaging_api::models::NumberOfMessagesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_number_of_sent_push_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNumberOfSentPushMessagesSuccess {
    Status200(crate::messaging_api::models::NumberOfMessagesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_number_of_sent_reply_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNumberOfSentReplyMessagesSuccess {
    Status200(crate::messaging_api::models::NumberOfMessagesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_pnp_message_statistics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPnpMessageStatisticsSuccess {
    Status200(crate::messaging_api::models::NumberOfMessagesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProfileSuccess {
    Status200(crate::messaging_api::models::UserProfileResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_rich_menu`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuSuccess {
    Status200(crate::messaging_api::models::RichMenuResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_rich_menu_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuAliasSuccess {
    Status200(crate::messaging_api::models::RichMenuAliasResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_rich_menu_alias_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuAliasListSuccess {
    Status200(crate::messaging_api::models::RichMenuAliasListResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_rich_menu_batch_progress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuBatchProgressSuccess {
    Status200(crate::messaging_api::models::RichMenuBatchProgressResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_rich_menu_id_of_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuIdOfUserSuccess {
    Status200(crate::messaging_api::models::RichMenuIdResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_rich_menu_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuListSuccess {
    Status200(crate::messaging_api::models::RichMenuListResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_room_member_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRoomMemberCountSuccess {
    Status200(crate::messaging_api::models::RoomMemberCountResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_room_member_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRoomMemberProfileSuccess {
    Status200(crate::messaging_api::models::RoomUserProfileResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_room_members_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRoomMembersIdsSuccess {
    Status200(crate::messaging_api::models::MembersIdsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_webhook_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebhookEndpointSuccess {
    Status200(crate::messaging_api::models::GetWebhookEndpointResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`issue_link_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueLinkTokenSuccess {
    Status200(crate::messaging_api::models::IssueLinkTokenResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`leave_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaveGroupSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`leave_room`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaveRoomSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`link_rich_menu_id_to_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LinkRichMenuIdToUserSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`link_rich_menu_id_to_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LinkRichMenuIdToUsersSuccess {
    Status202(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`mark_messages_as_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarkMessagesAsReadSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`multicast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MulticastSuccess {
    Status200(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`narrowcast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NarrowcastSuccess {
    Status202(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`push_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PushMessageSuccess {
    Status200(crate::messaging_api::models::PushMessageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`push_messages_by_phone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PushMessagesByPhoneSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`reply_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplyMessageSuccess {
    Status200(crate::messaging_api::models::ReplyMessageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`rich_menu_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RichMenuBatchSuccess {
    Status202(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`set_default_rich_menu`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetDefaultRichMenuSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`set_webhook_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetWebhookEndpointSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`test_webhook_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TestWebhookEndpointSuccess {
    Status200(crate::messaging_api::models::TestWebhookEndpointResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`unlink_rich_menu_id_from_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnlinkRichMenuIdFromUserSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`unlink_rich_menu_id_from_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnlinkRichMenuIdFromUsersSuccess {
    Status202(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_rich_menu_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRichMenuAliasSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`validate_broadcast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateBroadcastSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`validate_multicast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateMulticastSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`validate_narrowcast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateNarrowcastSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`validate_push`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatePushSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`validate_reply`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateReplySuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`validate_rich_menu_batch_request`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateRichMenuBatchRequestSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`validate_rich_menu_object`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateRichMenuObjectSuccess {
    Status200(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`audience_match`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AudienceMatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`broadcast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BroadcastError {
    Status400(crate::messaging_api::models::ErrorResponse),
    Status403(crate::messaging_api::models::ErrorResponse),
    Status409(crate::messaging_api::models::ErrorResponse),
    Status429(crate::messaging_api::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_default_rich_menu`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelDefaultRichMenuError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_rich_menu`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRichMenuError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_rich_menu_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRichMenuAliasError {
    Status400(crate::messaging_api::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_rich_menu`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRichMenuError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_rich_menu_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRichMenuAliasError {
    Status400(crate::messaging_api::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ad_phone_message_statistics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAdPhoneMessageStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_aggregation_unit_name_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAggregationUnitNameListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_aggregation_unit_usage`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAggregationUnitUsageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_bot_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBotInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_default_rich_menu_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultRichMenuIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_followers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFollowersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_member_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupMemberCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_member_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupMemberProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_members_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupMembersIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupSummaryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_message_quota`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMessageQuotaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_message_quota_consumption`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMessageQuotaConsumptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_narrowcast_progress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNarrowcastProgressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_number_of_sent_broadcast_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNumberOfSentBroadcastMessagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_number_of_sent_multicast_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNumberOfSentMulticastMessagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_number_of_sent_push_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNumberOfSentPushMessagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_number_of_sent_reply_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNumberOfSentReplyMessagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pnp_message_statistics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPnpMessageStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rich_menu`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rich_menu_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuAliasError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rich_menu_alias_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuAliasListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rich_menu_batch_progress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuBatchProgressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rich_menu_id_of_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuIdOfUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rich_menu_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRichMenuListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_room_member_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRoomMemberCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_room_member_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRoomMemberProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_room_members_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRoomMembersIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webhook_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebhookEndpointError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issue_link_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueLinkTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`leave_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaveGroupError {
    Status400(crate::messaging_api::models::ErrorResponse),
    Status404(crate::messaging_api::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`leave_room`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaveRoomError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`link_rich_menu_id_to_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LinkRichMenuIdToUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`link_rich_menu_id_to_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LinkRichMenuIdToUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mark_messages_as_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarkMessagesAsReadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`multicast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MulticastError {
    Status400(crate::messaging_api::models::ErrorResponse),
    Status403(crate::messaging_api::models::ErrorResponse),
    Status409(crate::messaging_api::models::ErrorResponse),
    Status429(crate::messaging_api::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`narrowcast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NarrowcastError {
    Status400(crate::messaging_api::models::ErrorResponse),
    Status403(crate::messaging_api::models::ErrorResponse),
    Status409(crate::messaging_api::models::ErrorResponse),
    Status429(crate::messaging_api::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`push_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PushMessageError {
    Status400(crate::messaging_api::models::ErrorResponse),
    Status403(crate::messaging_api::models::ErrorResponse),
    Status409(crate::messaging_api::models::ErrorResponse),
    Status429(crate::messaging_api::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`push_messages_by_phone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PushMessagesByPhoneError {
    Status422(crate::messaging_api::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reply_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplyMessageError {
    Status400(crate::messaging_api::models::ErrorResponse),
    Status429(crate::messaging_api::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rich_menu_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RichMenuBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_default_rich_menu`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetDefaultRichMenuError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_webhook_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetWebhookEndpointError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`test_webhook_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TestWebhookEndpointError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unlink_rich_menu_id_from_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnlinkRichMenuIdFromUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unlink_rich_menu_id_from_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnlinkRichMenuIdFromUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_rich_menu_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRichMenuAliasError {
    Status400(crate::messaging_api::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_broadcast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateBroadcastError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_multicast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateMulticastError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_narrowcast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateNarrowcastError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_push`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatePushError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_reply`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateReplyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_rich_menu_batch_request`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateRichMenuBatchRequestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_rich_menu_object`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateRichMenuObjectError {
    UnknownValue(serde_json::Value),
}

/// Send a message using phone number
pub async fn audience_match(
    configuration: &configuration::Configuration,
    params: AudienceMatchParams,
) -> Result<ResponseContent<AudienceMatchSuccess>, Error<AudienceMatchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let audience_match_messages_request = params.audience_match_messages_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/bot/ad/multicast/phone",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&audience_match_messages_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<AudienceMatchSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<AudienceMatchError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sends a message to multiple users at any time.
pub async fn broadcast(
    configuration: &configuration::Configuration,
    params: BroadcastParams,
) -> Result<ResponseContent<BroadcastSuccess>, Error<BroadcastError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let broadcast_request = params.broadcast_request;
    let x_line_retry_key = params.x_line_retry_key;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/broadcast",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_line_retry_key {
        local_var_req_builder =
            local_var_req_builder.header("X-Line-Retry-Key", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&broadcast_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<BroadcastSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<BroadcastError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cancel default rich menu
pub async fn cancel_default_rich_menu(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<CancelDefaultRichMenuSuccess>, Error<CancelDefaultRichMenuError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/user/all/richmenu",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CancelDefaultRichMenuSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CancelDefaultRichMenuError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create rich menu
pub async fn create_rich_menu(
    configuration: &configuration::Configuration,
    params: CreateRichMenuParams,
) -> Result<ResponseContent<CreateRichMenuSuccess>, Error<CreateRichMenuError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_request = params.rich_menu_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/bot/richmenu", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rich_menu_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRichMenuSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRichMenuError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create rich menu alias
pub async fn create_rich_menu_alias(
    configuration: &configuration::Configuration,
    params: CreateRichMenuAliasParams,
) -> Result<ResponseContent<CreateRichMenuAliasSuccess>, Error<CreateRichMenuAliasError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_rich_menu_alias_request = params.create_rich_menu_alias_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/alias",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_rich_menu_alias_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRichMenuAliasSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRichMenuAliasError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a rich menu.
pub async fn delete_rich_menu(
    configuration: &configuration::Configuration,
    params: DeleteRichMenuParams,
) -> Result<ResponseContent<DeleteRichMenuSuccess>, Error<DeleteRichMenuError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_id = params.rich_menu_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/{richMenuId}",
        local_var_configuration.base_path,
        richMenuId = crate::messaging_api::apis::urlencode(rich_menu_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRichMenuSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRichMenuError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete rich menu alias
pub async fn delete_rich_menu_alias(
    configuration: &configuration::Configuration,
    params: DeleteRichMenuAliasParams,
) -> Result<ResponseContent<DeleteRichMenuAliasSuccess>, Error<DeleteRichMenuAliasError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_alias_id = params.rich_menu_alias_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/alias/{richMenuAliasId}",
        local_var_configuration.base_path,
        richMenuAliasId = crate::messaging_api::apis::urlencode(rich_menu_alias_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRichMenuAliasSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRichMenuAliasError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get result of message delivery using phone number
pub async fn get_ad_phone_message_statistics(
    configuration: &configuration::Configuration,
    params: GetAdPhoneMessageStatisticsParams,
) -> Result<
    ResponseContent<GetAdPhoneMessageStatisticsSuccess>,
    Error<GetAdPhoneMessageStatisticsError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let date = params.date;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/delivery/ad_phone",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("date", &date.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetAdPhoneMessageStatisticsSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetAdPhoneMessageStatisticsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get name list of units used this month
pub async fn get_aggregation_unit_name_list(
    configuration: &configuration::Configuration,
    params: GetAggregationUnitNameListParams,
) -> Result<
    ResponseContent<GetAggregationUnitNameListSuccess>,
    Error<GetAggregationUnitNameListError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let limit = params.limit;
    let start = params.start;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/aggregation/list",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetAggregationUnitNameListSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetAggregationUnitNameListError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get number of units used this month
pub async fn get_aggregation_unit_usage(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<GetAggregationUnitUsageSuccess>, Error<GetAggregationUnitUsageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/aggregation/info",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetAggregationUnitUsageSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetAggregationUnitUsageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get bot info
pub async fn get_bot_info(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<GetBotInfoSuccess>, Error<GetBotInfoError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/bot/info", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetBotInfoSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetBotInfoError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets the ID of the default rich menu set with the Messaging API.
pub async fn get_default_rich_menu_id(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<GetDefaultRichMenuIdSuccess>, Error<GetDefaultRichMenuIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/user/all/richmenu",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetDefaultRichMenuIdSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetDefaultRichMenuIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a list of users who added your LINE Official Account as a friend
pub async fn get_followers(
    configuration: &configuration::Configuration,
    params: GetFollowersParams,
) -> Result<ResponseContent<GetFollowersSuccess>, Error<GetFollowersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let start = params.start;
    let limit = params.limit;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/bot/followers/ids", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetFollowersSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetFollowersError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get number of users in a group chat
pub async fn get_group_member_count(
    configuration: &configuration::Configuration,
    params: GetGroupMemberCountParams,
) -> Result<ResponseContent<GetGroupMemberCountSuccess>, Error<GetGroupMemberCountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let group_id = params.group_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/group/{groupId}/members/count",
        local_var_configuration.base_path,
        groupId = crate::messaging_api::apis::urlencode(group_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetGroupMemberCountSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetGroupMemberCountError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get group chat member profile
pub async fn get_group_member_profile(
    configuration: &configuration::Configuration,
    params: GetGroupMemberProfileParams,
) -> Result<ResponseContent<GetGroupMemberProfileSuccess>, Error<GetGroupMemberProfileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let group_id = params.group_id;
    let user_id = params.user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/group/{groupId}/member/{userId}",
        local_var_configuration.base_path,
        groupId = crate::messaging_api::apis::urlencode(group_id),
        userId = crate::messaging_api::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetGroupMemberProfileSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetGroupMemberProfileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get group chat member user IDs
pub async fn get_group_members_ids(
    configuration: &configuration::Configuration,
    params: GetGroupMembersIdsParams,
) -> Result<ResponseContent<GetGroupMembersIdsSuccess>, Error<GetGroupMembersIdsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let group_id = params.group_id;
    let start = params.start;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/group/{groupId}/members/ids",
        local_var_configuration.base_path,
        groupId = crate::messaging_api::apis::urlencode(group_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetGroupMembersIdsSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetGroupMembersIdsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get group chat summary
pub async fn get_group_summary(
    configuration: &configuration::Configuration,
    params: GetGroupSummaryParams,
) -> Result<ResponseContent<GetGroupSummarySuccess>, Error<GetGroupSummaryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let group_id = params.group_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/group/{groupId}/summary",
        local_var_configuration.base_path,
        groupId = crate::messaging_api::apis::urlencode(group_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetGroupSummarySuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetGroupSummaryError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets the target limit for sending messages in the current month. The total number of the free messages and the additional messages is returned.
pub async fn get_message_quota(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<GetMessageQuotaSuccess>, Error<GetMessageQuotaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/bot/message/quota", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetMessageQuotaSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetMessageQuotaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets the number of messages sent in the current month.
pub async fn get_message_quota_consumption(
    configuration: &configuration::Configuration,
) -> Result<
    ResponseContent<GetMessageQuotaConsumptionSuccess>,
    Error<GetMessageQuotaConsumptionError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/quota/consumption",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetMessageQuotaConsumptionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetMessageQuotaConsumptionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets the status of a narrowcast message.
pub async fn get_narrowcast_progress(
    configuration: &configuration::Configuration,
    params: GetNarrowcastProgressParams,
) -> Result<ResponseContent<GetNarrowcastProgressSuccess>, Error<GetNarrowcastProgressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let request_id = params.request_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/progress/narrowcast",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("requestId", &request_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetNarrowcastProgressSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetNarrowcastProgressError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get number of sent broadcast messages
pub async fn get_number_of_sent_broadcast_messages(
    configuration: &configuration::Configuration,
    params: GetNumberOfSentBroadcastMessagesParams,
) -> Result<
    ResponseContent<GetNumberOfSentBroadcastMessagesSuccess>,
    Error<GetNumberOfSentBroadcastMessagesError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let date = params.date;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/delivery/broadcast",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("date", &date.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetNumberOfSentBroadcastMessagesSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetNumberOfSentBroadcastMessagesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get number of sent multicast messages
pub async fn get_number_of_sent_multicast_messages(
    configuration: &configuration::Configuration,
    params: GetNumberOfSentMulticastMessagesParams,
) -> Result<
    ResponseContent<GetNumberOfSentMulticastMessagesSuccess>,
    Error<GetNumberOfSentMulticastMessagesError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let date = params.date;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/delivery/multicast",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("date", &date.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetNumberOfSentMulticastMessagesSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetNumberOfSentMulticastMessagesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get number of sent push messages
pub async fn get_number_of_sent_push_messages(
    configuration: &configuration::Configuration,
    params: GetNumberOfSentPushMessagesParams,
) -> Result<
    ResponseContent<GetNumberOfSentPushMessagesSuccess>,
    Error<GetNumberOfSentPushMessagesError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let date = params.date;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/delivery/push",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("date", &date.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetNumberOfSentPushMessagesSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetNumberOfSentPushMessagesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get number of sent reply messages
pub async fn get_number_of_sent_reply_messages(
    configuration: &configuration::Configuration,
    params: GetNumberOfSentReplyMessagesParams,
) -> Result<
    ResponseContent<GetNumberOfSentReplyMessagesSuccess>,
    Error<GetNumberOfSentReplyMessagesError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let date = params.date;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/delivery/reply",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("date", &date.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetNumberOfSentReplyMessagesSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetNumberOfSentReplyMessagesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get number of sent LINE notification messages
pub async fn get_pnp_message_statistics(
    configuration: &configuration::Configuration,
    params: GetPnpMessageStatisticsParams,
) -> Result<ResponseContent<GetPnpMessageStatisticsSuccess>, Error<GetPnpMessageStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let date = params.date;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/delivery/pnp",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("date", &date.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetPnpMessageStatisticsSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetPnpMessageStatisticsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get profile
pub async fn get_profile(
    configuration: &configuration::Configuration,
    params: GetProfileParams,
) -> Result<ResponseContent<GetProfileSuccess>, Error<GetProfileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/profile/{userId}",
        local_var_configuration.base_path,
        userId = crate::messaging_api::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetProfileSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetProfileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a rich menu via a rich menu ID.
pub async fn get_rich_menu(
    configuration: &configuration::Configuration,
    params: GetRichMenuParams,
) -> Result<ResponseContent<GetRichMenuSuccess>, Error<GetRichMenuError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_id = params.rich_menu_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/{richMenuId}",
        local_var_configuration.base_path,
        richMenuId = crate::messaging_api::apis::urlencode(rich_menu_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRichMenuSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRichMenuError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get rich menu alias information
pub async fn get_rich_menu_alias(
    configuration: &configuration::Configuration,
    params: GetRichMenuAliasParams,
) -> Result<ResponseContent<GetRichMenuAliasSuccess>, Error<GetRichMenuAliasError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_alias_id = params.rich_menu_alias_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/alias/{richMenuAliasId}",
        local_var_configuration.base_path,
        richMenuAliasId = crate::messaging_api::apis::urlencode(rich_menu_alias_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRichMenuAliasSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRichMenuAliasError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get list of rich menu alias
pub async fn get_rich_menu_alias_list(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<GetRichMenuAliasListSuccess>, Error<GetRichMenuAliasListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/alias/list",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRichMenuAliasListSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRichMenuAliasListError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the status of Replace or unlink a linked rich menus in batches.
pub async fn get_rich_menu_batch_progress(
    configuration: &configuration::Configuration,
    params: GetRichMenuBatchProgressParams,
) -> Result<ResponseContent<GetRichMenuBatchProgressSuccess>, Error<GetRichMenuBatchProgressError>>
{
    let local_var_configuration = configuration;

    // unbox the parameters
    let request_id = params.request_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/progress/batch",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("requestId", &request_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRichMenuBatchProgressSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRichMenuBatchProgressError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get rich menu ID of user
pub async fn get_rich_menu_id_of_user(
    configuration: &configuration::Configuration,
    params: GetRichMenuIdOfUserParams,
) -> Result<ResponseContent<GetRichMenuIdOfUserSuccess>, Error<GetRichMenuIdOfUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/user/{userId}/richmenu",
        local_var_configuration.base_path,
        userId = crate::messaging_api::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRichMenuIdOfUserSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRichMenuIdOfUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get rich menu list
pub async fn get_rich_menu_list(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<GetRichMenuListSuccess>, Error<GetRichMenuListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/bot/richmenu/list", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRichMenuListSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRichMenuListError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get number of users in a multi-person chat
pub async fn get_room_member_count(
    configuration: &configuration::Configuration,
    params: GetRoomMemberCountParams,
) -> Result<ResponseContent<GetRoomMemberCountSuccess>, Error<GetRoomMemberCountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_id = params.room_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/room/{roomId}/members/count",
        local_var_configuration.base_path,
        roomId = crate::messaging_api::apis::urlencode(room_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRoomMemberCountSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRoomMemberCountError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get multi-person chat member profile
pub async fn get_room_member_profile(
    configuration: &configuration::Configuration,
    params: GetRoomMemberProfileParams,
) -> Result<ResponseContent<GetRoomMemberProfileSuccess>, Error<GetRoomMemberProfileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_id = params.room_id;
    let user_id = params.user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/room/{roomId}/member/{userId}",
        local_var_configuration.base_path,
        roomId = crate::messaging_api::apis::urlencode(room_id),
        userId = crate::messaging_api::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRoomMemberProfileSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRoomMemberProfileError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get multi-person chat member user IDs
pub async fn get_room_members_ids(
    configuration: &configuration::Configuration,
    params: GetRoomMembersIdsParams,
) -> Result<ResponseContent<GetRoomMembersIdsSuccess>, Error<GetRoomMembersIdsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_id = params.room_id;
    let start = params.start;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/room/{roomId}/members/ids",
        local_var_configuration.base_path,
        roomId = crate::messaging_api::apis::urlencode(room_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRoomMembersIdsSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRoomMembersIdsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get webhook endpoint information
pub async fn get_webhook_endpoint(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<GetWebhookEndpointSuccess>, Error<GetWebhookEndpointError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/channel/webhook/endpoint",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetWebhookEndpointSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetWebhookEndpointError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Issue link token
pub async fn issue_link_token(
    configuration: &configuration::Configuration,
    params: IssueLinkTokenParams,
) -> Result<ResponseContent<IssueLinkTokenSuccess>, Error<IssueLinkTokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/user/{userId}/linkToken",
        local_var_configuration.base_path,
        userId = crate::messaging_api::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<IssueLinkTokenSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<IssueLinkTokenError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Leave group chat
pub async fn leave_group(
    configuration: &configuration::Configuration,
    params: LeaveGroupParams,
) -> Result<ResponseContent<LeaveGroupSuccess>, Error<LeaveGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let group_id = params.group_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/group/{groupId}/leave",
        local_var_configuration.base_path,
        groupId = crate::messaging_api::apis::urlencode(group_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<LeaveGroupSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<LeaveGroupError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Leave multi-person chat
pub async fn leave_room(
    configuration: &configuration::Configuration,
    params: LeaveRoomParams,
) -> Result<ResponseContent<LeaveRoomSuccess>, Error<LeaveRoomError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_id = params.room_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/room/{roomId}/leave",
        local_var_configuration.base_path,
        roomId = crate::messaging_api::apis::urlencode(room_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<LeaveRoomSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<LeaveRoomError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Link rich menu to user.
pub async fn link_rich_menu_id_to_user(
    configuration: &configuration::Configuration,
    params: LinkRichMenuIdToUserParams,
) -> Result<ResponseContent<LinkRichMenuIdToUserSuccess>, Error<LinkRichMenuIdToUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;
    let rich_menu_id = params.rich_menu_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/user/{userId}/richmenu/{richMenuId}",
        local_var_configuration.base_path,
        userId = crate::messaging_api::apis::urlencode(user_id),
        richMenuId = crate::messaging_api::apis::urlencode(rich_menu_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<LinkRichMenuIdToUserSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<LinkRichMenuIdToUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Link rich menu to multiple users
pub async fn link_rich_menu_id_to_users(
    configuration: &configuration::Configuration,
    params: LinkRichMenuIdToUsersParams,
) -> Result<ResponseContent<LinkRichMenuIdToUsersSuccess>, Error<LinkRichMenuIdToUsersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_bulk_link_request = params.rich_menu_bulk_link_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/bulk/link",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rich_menu_bulk_link_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<LinkRichMenuIdToUsersSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<LinkRichMenuIdToUsersError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Mark messages from users as read
pub async fn mark_messages_as_read(
    configuration: &configuration::Configuration,
    params: MarkMessagesAsReadParams,
) -> Result<ResponseContent<MarkMessagesAsReadSuccess>, Error<MarkMessagesAsReadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let mark_messages_as_read_request = params.mark_messages_as_read_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/markAsRead",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&mark_messages_as_read_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<MarkMessagesAsReadSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<MarkMessagesAsReadError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// An API that efficiently sends the same message to multiple user IDs. You can't send messages to group chats or multi-person chats.
pub async fn multicast(
    configuration: &configuration::Configuration,
    params: MulticastParams,
) -> Result<ResponseContent<MulticastSuccess>, Error<MulticastError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let multicast_request = params.multicast_request;
    let x_line_retry_key = params.x_line_retry_key;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/multicast",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_line_retry_key {
        local_var_req_builder =
            local_var_req_builder.header("X-Line-Retry-Key", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&multicast_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<MulticastSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<MulticastError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Send narrowcast message
pub async fn narrowcast(
    configuration: &configuration::Configuration,
    params: NarrowcastParams,
) -> Result<ResponseContent<NarrowcastSuccess>, Error<NarrowcastError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let narrowcast_request = params.narrowcast_request;
    let x_line_retry_key = params.x_line_retry_key;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/narrowcast",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_line_retry_key {
        local_var_req_builder =
            local_var_req_builder.header("X-Line-Retry-Key", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&narrowcast_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<NarrowcastSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<NarrowcastError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sends a message to a user, group chat, or multi-person chat at any time.
pub async fn push_message(
    configuration: &configuration::Configuration,
    params: PushMessageParams,
) -> Result<ResponseContent<PushMessageSuccess>, Error<PushMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let push_message_request = params.push_message_request;
    let x_line_retry_key = params.x_line_retry_key;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/bot/message/push", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_line_retry_key {
        local_var_req_builder =
            local_var_req_builder.header("X-Line-Retry-Key", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&push_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<PushMessageSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<PushMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Send LINE notification message
pub async fn push_messages_by_phone(
    configuration: &configuration::Configuration,
    params: PushMessagesByPhoneParams,
) -> Result<ResponseContent<PushMessagesByPhoneSuccess>, Error<PushMessagesByPhoneError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pnp_messages_request = params.pnp_messages_request;
    let x_line_delivery_tag = params.x_line_delivery_tag;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/bot/pnp/push", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_line_delivery_tag {
        local_var_req_builder =
            local_var_req_builder.header("X-Line-Delivery-Tag", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&pnp_messages_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<PushMessagesByPhoneSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<PushMessagesByPhoneError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Send reply message
pub async fn reply_message(
    configuration: &configuration::Configuration,
    params: ReplyMessageParams,
) -> Result<ResponseContent<ReplyMessageSuccess>, Error<ReplyMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let reply_message_request = params.reply_message_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/bot/message/reply", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&reply_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ReplyMessageSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ReplyMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// You can use this endpoint to batch control the rich menu linked to the users using the endpoint such as Link rich menu to user.  The following operations are available:  1. Replace a rich menu with another rich menu for all users linked to a specific rich menu 2. Unlink a rich menu for all users linked to a specific rich menu 3. Unlink a rich menu for all users linked the rich menu
pub async fn rich_menu_batch(
    configuration: &configuration::Configuration,
    params: RichMenuBatchParams,
) -> Result<ResponseContent<RichMenuBatchSuccess>, Error<RichMenuBatchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_batch_request = params.rich_menu_batch_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/batch",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rich_menu_batch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<RichMenuBatchSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<RichMenuBatchError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set default rich menu
pub async fn set_default_rich_menu(
    configuration: &configuration::Configuration,
    params: SetDefaultRichMenuParams,
) -> Result<ResponseContent<SetDefaultRichMenuSuccess>, Error<SetDefaultRichMenuError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_id = params.rich_menu_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/user/all/richmenu/{richMenuId}",
        local_var_configuration.base_path,
        richMenuId = crate::messaging_api::apis::urlencode(rich_menu_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<SetDefaultRichMenuSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<SetDefaultRichMenuError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set webhook endpoint URL
pub async fn set_webhook_endpoint(
    configuration: &configuration::Configuration,
    params: SetWebhookEndpointParams,
) -> Result<ResponseContent<SetWebhookEndpointSuccess>, Error<SetWebhookEndpointError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let set_webhook_endpoint_request = params.set_webhook_endpoint_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/channel/webhook/endpoint",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&set_webhook_endpoint_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<SetWebhookEndpointSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<SetWebhookEndpointError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Test webhook endpoint
pub async fn test_webhook_endpoint(
    configuration: &configuration::Configuration,
    params: TestWebhookEndpointParams,
) -> Result<ResponseContent<TestWebhookEndpointSuccess>, Error<TestWebhookEndpointError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let test_webhook_endpoint_request = params.test_webhook_endpoint_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/channel/webhook/test",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&test_webhook_endpoint_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<TestWebhookEndpointSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<TestWebhookEndpointError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Unlink rich menu from user
pub async fn unlink_rich_menu_id_from_user(
    configuration: &configuration::Configuration,
    params: UnlinkRichMenuIdFromUserParams,
) -> Result<ResponseContent<UnlinkRichMenuIdFromUserSuccess>, Error<UnlinkRichMenuIdFromUserError>>
{
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/user/{userId}/richmenu",
        local_var_configuration.base_path,
        userId = crate::messaging_api::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UnlinkRichMenuIdFromUserSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UnlinkRichMenuIdFromUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Unlink rich menus from multiple users
pub async fn unlink_rich_menu_id_from_users(
    configuration: &configuration::Configuration,
    params: UnlinkRichMenuIdFromUsersParams,
) -> Result<ResponseContent<UnlinkRichMenuIdFromUsersSuccess>, Error<UnlinkRichMenuIdFromUsersError>>
{
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_bulk_unlink_request = params.rich_menu_bulk_unlink_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/bulk/unlink",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rich_menu_bulk_unlink_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UnlinkRichMenuIdFromUsersSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UnlinkRichMenuIdFromUsersError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update rich menu alias
pub async fn update_rich_menu_alias(
    configuration: &configuration::Configuration,
    params: UpdateRichMenuAliasParams,
) -> Result<ResponseContent<UpdateRichMenuAliasSuccess>, Error<UpdateRichMenuAliasError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_alias_id = params.rich_menu_alias_id;
    let update_rich_menu_alias_request = params.update_rich_menu_alias_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/alias/{richMenuAliasId}",
        local_var_configuration.base_path,
        richMenuAliasId = crate::messaging_api::apis::urlencode(rich_menu_alias_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_rich_menu_alias_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRichMenuAliasSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRichMenuAliasError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Validate message objects of a broadcast message
pub async fn validate_broadcast(
    configuration: &configuration::Configuration,
    params: ValidateBroadcastParams,
) -> Result<ResponseContent<ValidateBroadcastSuccess>, Error<ValidateBroadcastError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validate_message_request = params.validate_message_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/validate/broadcast",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&validate_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ValidateBroadcastSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ValidateBroadcastError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Validate message objects of a multicast message
pub async fn validate_multicast(
    configuration: &configuration::Configuration,
    params: ValidateMulticastParams,
) -> Result<ResponseContent<ValidateMulticastSuccess>, Error<ValidateMulticastError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validate_message_request = params.validate_message_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/validate/multicast",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&validate_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ValidateMulticastSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ValidateMulticastError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Validate message objects of a narrowcast message
pub async fn validate_narrowcast(
    configuration: &configuration::Configuration,
    params: ValidateNarrowcastParams,
) -> Result<ResponseContent<ValidateNarrowcastSuccess>, Error<ValidateNarrowcastError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validate_message_request = params.validate_message_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/validate/narrowcast",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&validate_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ValidateNarrowcastSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ValidateNarrowcastError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Validate message objects of a push message
pub async fn validate_push(
    configuration: &configuration::Configuration,
    params: ValidatePushParams,
) -> Result<ResponseContent<ValidatePushSuccess>, Error<ValidatePushError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validate_message_request = params.validate_message_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/validate/push",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&validate_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ValidatePushSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ValidatePushError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Validate message objects of a reply message
pub async fn validate_reply(
    configuration: &configuration::Configuration,
    params: ValidateReplyParams,
) -> Result<ResponseContent<ValidateReplySuccess>, Error<ValidateReplyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let validate_message_request = params.validate_message_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/message/validate/reply",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&validate_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ValidateReplySuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ValidateReplyError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Validate a request body of the Replace or unlink the linked rich menus in batches endpoint.
pub async fn validate_rich_menu_batch_request(
    configuration: &configuration::Configuration,
    params: ValidateRichMenuBatchRequestParams,
) -> Result<
    ResponseContent<ValidateRichMenuBatchRequestSuccess>,
    Error<ValidateRichMenuBatchRequestError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_batch_request = params.rich_menu_batch_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/validate/batch",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rich_menu_batch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ValidateRichMenuBatchRequestSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ValidateRichMenuBatchRequestError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Validate rich menu object
pub async fn validate_rich_menu_object(
    configuration: &configuration::Configuration,
    params: ValidateRichMenuObjectParams,
) -> Result<ResponseContent<ValidateRichMenuObjectSuccess>, Error<ValidateRichMenuObjectError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let rich_menu_request = params.rich_menu_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/bot/richmenu/validate",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rich_menu_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ValidateRichMenuObjectSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ValidateRichMenuObjectError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
